<html>
<head>
<title>Air Hockey</title>
<audio style="display: none;" controls autoplay="true" loop="true" id="audio"><source src="pinball.mp3" type="audio/mp3"></audio>
<style>
    ::-webkit-scrollbar{display: none;}
  * { padding: 0; margin: 0; }
    canvas { background: #eee; display: block; margin: 0px auto; margin-top: 20px; width:95%; height:100%;}

    // Colors
@red: fade(#bb0422, 25%);
@blue: fade(#304f86, 25%);
@black: #2e2e2e;
@grey: #F1F0F4;
@grey-dark: #7A7A7A;
@ice: #FFF;

// Table
@table-width: 800px;
@table-height: 550px;
@table-border: 15px;
@table-border-2x: @table-border * 2;

@line-width: 5px;
@blue-line-pos: 37%;
@circle-center-size: 140px;
@goal-size: 190px;

@table-faceoff-size: 80px;
@table-faceoff-pos: 20%;

* {
	box-sizing: border-box;
}

html,body{
	background-color: @grey;
	font-family: helvetica;
    width:100%; height:100%;
}
a {
	color: @grey-dark;
	text-decoration: none;
	transition: .3s opacity ease-out;
	
	&:hover,
	&:focus {
		opacity: .6;
	}
}

.circle {
	width: @circle-center-size;
	height: @circle-center-size;
	border-radius: 100%;
	border: @line-width solid @blue;
	position: absolute;
	top: 50%;
	left: 50%;
	margin-top: -(@circle-center-size/2);
	margin-left: -(@circle-center-size/2);
}

// Table
.table {
	width: @table-width;
	height: @table-height;
	margin-top: -(@table-height / 2);			
	margin-left: -(@table-width / 2);
	position: absolute;
	top: 50%;
	left: 50%;
	border: @table-border solid @black;
	border-radius: 70px;
	background-color: @ice;
	box-shadow: inset 0 2px 5px 0 rgba(50, 50, 50, 0.25);
	
	&:before,
	&:after {
		content: '';
		position: absolute;
		background-color: @grey-dark;
		width: @table-border;
		height: @goal-size;
		top: 50%;
		left: -@table-border;
		margin-top: -(@goal-size / 2);
	}
	
	&:after {
		left: auto;
		right: -@table-border;
	}
}

.table--canvas {
	width: @table-width - @table-border-2x;
	height: @table-height - @table-border-2x;
	margin-top: -((@table-height - @table-border-2x) / 2);			
	margin-left: -((@table-width - @table-border-2x) / 2);
	background-color: transparent;
	border-radius: 55px;
	border: none;
	
	&:focus {
		outline: none;
	}
}

.table-inner {
	overflow: hidden;
	display: block;
	position: relative;
	width: 100%;
	height: 100%;
}

.table__center-line {
	width: @line-width;
	height: 100%;
	background-color: @red;
	position: absolute;
	left: 50%;
	margin-left: -(@line-width/2);
}


// Blue lines
.table__blue-line {
	position: absolute;
	left: @blue-line-pos;
	width: @line-width;
	margin-left: -(@line-width/2);
	height: 100%;
	background-color: @blue;
}

.table__blue-line--two {
	left: auto;
	right: @blue-line-pos;
	margin-left: 0;
	margin-right: -(@line-width/2);
}


// Goal creases
.table__goal-crease {
	left: 0;
	margin-top: -(@goal-size/2);
	margin-left: -(@goal-size/2) - (@table-border / 2);
	width: @goal-size;
	height: @goal-size;
	background-color:  fade(#304f86, 6%);
}

.table__goal-crease--two {
	left: auto;
	margin-left: auto;
	right: 0;
	margin-top: -(@goal-size/2);
	margin-right: -(@goal-size/2) - (@table-border / 2);
}


// Faceoff circles
.table__faceoff {
	width: @table-faceoff-size;
	height: @table-faceoff-size;
	border-color: @red;
	position: absolute;
}

.table__faceoff--top-left {
	margin-top: -(@table-faceoff-size/2);
	margin-left: -(@table-faceoff-size/2);
	left: @table-faceoff-pos;
	top: @table-faceoff-pos;	
}

.table__faceoff--top-right {
	margin-top: -(@table-faceoff-size/2);
	margin-right: -(@table-faceoff-size/2);
	right: @table-faceoff-pos;
	top: @table-faceoff-pos;	
	left: auto;
}

.table__faceoff--bottom-left {
	margin-bottom: -(@table-faceoff-size/2);
	margin-left: -(@table-faceoff-size/2);
	left: @table-faceoff-pos;
	bottom: @table-faceoff-pos;	
	top: auto;
}

.table__faceoff--bottom-right {
	margin-bottom: -(@table-faceoff-size/2);
	margin-right: -(@table-faceoff-size/2);
	right: @table-faceoff-pos;
	bottom: @table-faceoff-pos;	
	left: auto;
	top: auto;
}

.message {
	position: absolute;
	text-align: center;
	font-weight: bold;
	top: -60px;
	width: 100%;
	font-size: 18px;
	padding-top: 15px;
}
</style>
<body>
	<canvas id="canvas" width="520" height="660"></canvas>
	<script>
    var canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    var gm = true;
    var ball_speed = 10;
    var xspeed = 0;
    var yspeed = 0;
    var com_score = 0;
    var player_score = 0;
    var x_min=30;
    var x_max=460;
    var y_min=30;
    var y_max=600;

    document.addEventListener("mousemove", mouseMoveHandler, false);


    function draw_rect(x,y,w,h,b)
    {
        ctx.beginPath();
        if(b)
        {
            ctx.strokeStyle = "#33FFF2";
            ctx.lineWidth = 40;
        }
        else
        {
            ctx.strokeStyle = "#133FFF2";
            ctx.lineWidth = 4;
        }    
        ctx.strokeRect(x,y,w,h);
        ctx.closePath();
    }  
      
    function draw_goal(x,y,r,s)
    {
        ctx.beginPath();
        ctx.lineWidth=4;
        if(s)
          ctx.arc(x, y, r, 0, Math.PI, false);
        else
          ctx.arc(x, y, r, Math.PI, 0, false);

        ctx.strokeStyle = "#F7FF33";
        ctx.stroke();
        ctx.closePath();
    }

    function draw_circle(x,y,r,w)
    {
        ctx.beginPath();
        ctx.lineWidth=w;
        ctx.arc(x, y, r, 0, Math.PI*2, false);
        ctx.strokeStyle = "#1589FF";
        ctx.stroke();
        ctx.closePath();
    }

    function draw_filled_circle(x,y,r,d)
    {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        if(d==1)
        {
         ctx.fillStyle = "#3377FF";
         ctx.strokeStyle = "#3398FF";
        }
        else if(d==2)
        {
         ctx.fillStyle = "#ffdc00";
         ctx.strokeStyle = "#9F000F";
        }
        else
        {
         ctx.fillStyle = "#7D0552";
         ctx.strokeStyle = "#4CC417";   
        }    
        
        ctx.fill();
        ctx.lineWidth = 3;
        
        ctx.stroke();
        ctx.closePath();
    }

    function draw_board()
    {
        draw_rect(0,0,520,660,1);
        draw_rect(30,30,460,600,0);
        draw_goal(260,30,70,1);
        draw_goal(260,30,150,1);
        draw_goal(260,630,70,0);
        draw_goal(260,630,150,0);
        draw_circle(260,330,40,4);
        draw_circle(260,330,5,4);
        
        ctx.beginPath();
        ctx.moveTo(30, 330);
        ctx.lineTo(490, 330);
        ctx.stroke();
        ctx.closePath();

        ctx.beginPath();
        ctx.moveTo(190, 30);
        ctx.lineTo(330, 30);
        ctx.lineWidth = 4;
        ctx.strokeStyle = "#000";
        ctx.stroke();
        ctx.closePath();

        ctx.beginPath();
        ctx.moveTo(190, 630);
        ctx.lineTo(330, 630);
        //ctx.strokeStyle("#FFFFFF");
        ctx.stroke();
        ctx.closePath();

        ctx.font = "50px Pristina";
        ctx.lineWidth = 2
        ctx.strokeText(com_score,440,300);
        ctx.strokeText(player_score,440,380);
    }

    function distance(x1,y1,x2,y2)
    {
        var tempx = x2-x1;
        var tempy = y2-y1;
        tempx*=tempx;
        tempy*=tempy;
        return Math.sqrt(tempx+tempy);
    }


    var Mallet = function(x,y,r)
    {

        this.x = x;
        this.y = y;
        this.radius = r;
    }
    // Player's object
    var pMallet = new Mallet(260,canvas.height-100,30);
    
    var cMallet = new Mallet(260,100,30);

    // Ball class
    var Ball = function (x,y,r) {
        this.x = x;
        this.y = y;
        this.radius = r;
    }
    // ball object
    var ball = new Ball(canvas.width/2,canvas.height-200,15); 


    // function to control the mallet according to cursor
    function mouseMoveHandler(e) {
    var relativeX = e.clientX - canvas.offsetLeft;
    var relativeY = e.clientY -canvas.offsetTop;

       if(relativeX > 60 && relativeX < canvas.width-60) {
            pMallet.x = relativeX;
        }
        //360
       if(relativeY > 0 && relativeY < 600){
            pMallet.y = relativeY;
        }    
    }

   
        function play()
        {

           ctx.clearRect(0, 0, canvas.width, canvas.height);
           // draw draw the board
           draw_board();
           // drawing player's mallet
           draw_filled_circle(pMallet.x,pMallet.y,pMallet.radius,1);   
           // drawing computer's mallet
           draw_filled_circle(cMallet.x,cMallet.y,cMallet.radius,2);   
           // drawing the ball
           draw_filled_circle(ball.x,ball.y,ball.radius,0);

           // condition to counce the ball off the left-right walls
           if(ball.x + xspeed > canvas.width-ball.radius-30 || ball.x + xspeed < ball.radius + 30) {
                 xspeed *= -1;
            }
           
           // condition to bounce the ball off the top-botom walls and goal logic
           if(ball.x>190 && ball.x<330){
            if(ball.y + yspeed > canvas.height+ball.radius-30){
                console.log("Computer Score");
                ball.x = canvas.width/2;
                ball.y = canvas.height/2+100;
                xspeed = 0;
                yspeed = 0 ;
                com_score = com_score + 1;
            }
            else if(ball.y + yspeed < 30-ball.radius ){
                console.log("you Score");
                ball.x = canvas.width/2;
                ball.y = canvas.height/2-100;
                xspeed = 0;
                yspeed = 0;
                player_score = player_score + 1; 
            }
           }
           else{
            if(ball.y + yspeed > canvas.height-ball.radius-30  || ball.y + yspeed  < 30+ball.radius){
                yspeed *= -1;
            }
           }
          
        
        var ed = false; // enemy difficulty
        var er = 1;//Used in AI. This is so CPU doesn't just hit it down all the time.
        var p2s;//The speed CPU moves side to side
        if(ed){er=5;}//If hard, Make er larger so CPU hits it diagonally.

   

          if((Math.abs(xspeed)+Math.abs(yspeed))<10&&ball.y<=canvas.height/2){
              if(ball.y-20>cMallet.y){
                  cMallet.y+=2;
              }
              else{
                  cMallet.y-=2;
              }
          }
          else if(cMallet.y>100){
                  cMallet.y-=2;
          }
          else if(cMallet.y<100){
                  cMallet.y+=2;
          }


    //Make sure You or CPU doesn't go past the line or go off screen.
   if(cMallet.x<x_min)
      {cMallet.x=x_min+30;}
    if(cMallet.x>x_max)
      {cMallet.x=x_max+30;}
    if(cMallet.y<y_min)
      {cMallet.y=y_min+60;}
    if(cMallet.y>y_max)
      {cMallet.y=y_max;}
    
    //set CPU's speed depending on difficulty
    if(!ed){p2s = 2;}
    else{p2s=3;}
    
    //If the ball is behind CPU, it moves out of the way.
    if(ball.y<cMallet.y&&ball.x>cMallet.x-30&&ball.x<cMallet.x+30){p2s = -2;}
    //Make CPU move towards the ball's x coord
    if(cMallet.x<ball.x+er){cMallet.x+=p2s;}if(cMallet.x>ball.x-er){cMallet.x-=p2s;}
    
           


          var pDist = distance(pMallet.x,pMallet.y,ball.x,ball.y);
          
          var cDist = distance(cMallet.x,cMallet.y,ball.x,ball.y);          
          

          // Function to hit the ball for player
          if(pDist<45)
          {
           /* console.log("Mallet x : "+pMallet.x+" y : "+pMallet.y);
            console.log("Ball x : "+ball.x+" y : "+ball.y);
            console.log("Distance is : "+dist);
            console.log("dist<30"); */
            var dx = ball.x - pMallet.x;
            var dy = ball.y - pMallet.y;
            //console.log("dx  : " + dx);
            //console.log("dy  : " + dy);
            dx/=30;
            dy/=30;
            xspeed = dx*ball_speed;
            yspeed = dy*ball_speed;
          }  

          // Function to hit the ball when computer is playing
          if(cDist<45)
          {
            var cdx = ball.x - cMallet.x;
            var cdy = ball.y- cMallet.y;
            cdx/=45;
            cdy/=45;
            xspeed = cdx*ball_speed;
            yspeed = cdy*ball_speed;
          }

         // Adjustments in the x and y coordianate of  the ball
           ball.x += xspeed;
           ball.y += yspeed;

           xspeed *=0.99;
           yspeed *=0.99;
        }
         
        setInterval(play,10);   

    var board = document.getElementById("canvas"),
		boardContext = board.getContext('2d'),
		boardWidth = 770,
		boardHeight = 520,
		boardCenterX = boardWidth / 2,
		boardCenterY = boardHeight / 2,
		controllers = [],
		goal = document.getElementsByClassName('table__goal-crease'),
		goalHeight = goal[0].clientHeight,
		goalPosTop = (boardHeight - goalHeight) / 2,
		score = [];

// Set width & height for canvas
board.width = boardWidth;
board.height = boardHeight;

// Set focus to canvas so keyboard events work
board.focus();

// Disc
function Disc() {

		this.startingPosX = boardCenterX;
		this.startingPosY = boardCenterY;
		this.x = this.startingPosX;
		this.y = this.startingPosY;
		this.radius = 34;
		this.mass = 15;
		this.velocityX = 0;
		this.velocityY = 0;
		this.maxSpeed = 10;
		this.frictionX = 0.997;
		this.frictionY = 0.997;
		this.acceleration = 1;
		this.color = '#000000';

		this.keepControllerInBoard = function() {
			
				// Need to determine if goal scored on x axis as well
				if (this.x > (boardWidth - this.radius) || this.x < this.radius) {

					if (this.x < this.radius) {
							  this.velocityX = 2;
						} else {
								this.velocityX = -2;
						}
				}

				// Determine if disc is to far up or down
				if (this.y > (boardHeight - this.radius) || this.y < this.radius) {

						if (this.y < this.radius) {
							  this.velocityY = 2;
						} else {
								this.velocityY = -2;
						}

				}
			
				// Keep player one controller on left hand side of screen
				if (controller.x > (boardCenterX - controller.radius) && controller.x < boardCenterX) {
						controller.velocityX = -3;
				}

				// Keep player two controller on right hand side of screen
				if (controllerTwo.x > boardCenterX && controllerTwo.x < (boardCenterX + (controllerTwo.radius / 2))) {
						controllerTwo.velocityX = +3;
				} 
		},

		// Keep disc inside board
		this.keepPuckInBoard = function() {

				// Determine if disc is to far right or left
				// Need to determine if goal scored on x axis as well
				if (this.x > (boardWidth - this.radius) || this.x < this.radius) {

						// Stop puck from getting stuck
						if (this.x > (boardWidth - this.radius)) {
								this.x = boardWidth - this.radius;
						} else {
								this.x = this.radius;
						}

						// Check to see if goal scored
						if (this.y > (goalPosTop + puck.radius) && this.y < (goalPosTop + goalHeight) - puck.radius) {
								// Add new puck
								puck = new Disc(boardCenterX, boardCenterY);
						} else {
								// Reverse X direction 
								this.velocityX = -this.velocityX;
						}
				}

				// Determine if disc is to far up or down
				if (this.y > (boardHeight - this.radius) || this.y < this.radius) {

						// Stop puck from getting stuck
						if (this.y > (boardHeight - this.radius)) {
								this.y = boardHeight - this.radius;
						} else {
								this.y = this.radius;
						}
						
						// Reverse direction
						this.velocityY = -this.velocityY;
				}

		}

		// Collide discs if in same spot
		this.discCollision = function() {

				// Loop over two controllers to see if puck has come in contact
				for (var i = 0; i < controllers.length; i++) {
					
						// Minus the x pos of one disc from the x pos of the other disc
						var distanceX = this.x - controllers[i].x,
								// Minus the y pos of one disc from the y pos of the other disc
								distanceY = this.y - controllers[i].y,
								// Multiply each of the distances by this
								// Squareroot that number, which gives you the distance between the two disc's
								distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY),
								// Add the two disc radius together
								addedRadius = this.radius + controllers[i].radius;

						// Check to see if the distance between the two circles is smaller than the added radius
						// If it is then we know the circles are overlapping								
						if (distance < addedRadius) {
								
								// Had help from Reddit user Kraft_Punk on the below collision math
							
								//calculate angle, sine, and cosine
								var angle = Math.atan2(distanceY, distanceX),
										sin = Math.sin(angle),
										cos = Math.cos(angle),
										//rotate controllers[i]'s position
										pos0 = {
												x: 0,
												y: 0
										},
										//rotate this's position
										pos1 = rotate(distanceX, distanceY, sin, cos, true),
										//rotate controllers[i]'s velocity
										vel0 = rotate(controllers[i].velocityX, controllers[i].velocityY, sin, cos, true),
										//rotate this's velocity
										vel1 = rotate(this.velocityX, this.velocityY, sin, cos, true),
										//collision reaction
										velocityXTotal = vel0.x - vel1.x;

								vel0.x = ((controllers[i].mass - this.mass) * vel0.x + 2 * this.mass * vel1.x) /
										(controllers[i].mass + this.mass);
								vel1.x = velocityXTotal + vel0.x;

								//update position - to avoid objects becoming stuck together
								var absV = Math.abs(vel0.x) + Math.abs(vel1.x),
										overlap = (controllers[i].radius + this.radius) - Math.abs(pos0.x - pos1.x);

								pos0.x += vel0.x / absV * overlap;
								pos1.x += vel1.x / absV * overlap;

								//rotate positions back
								var pos0F = rotate(pos0.x, pos0.y, sin, cos, false),
										pos1F = rotate(pos1.x, pos1.y, sin, cos, false);

								//adjust positions to actual screen positions
								this.x = controllers[i].x + pos1F.x;
								this.y = controllers[i].y + pos1F.y;
								controllers[i].x = controllers[i].x + pos0F.x;
								controllers[i].y = controllers[i].y + pos0F.y;

								//rotate velocities back
								var vel0F = rotate(vel0.x, vel0.y, sin, cos, false),
										vel1F = rotate(vel1.x, vel1.y, sin, cos, false);

								controllers[i].velocityX = vel0F.x;
								controllers[i].velocityY = vel0F.y;

								this.velocityX = vel1F.x;
								this.velocityY = vel1F.y;

						}
				}

		}

		// Draw disc
		this.draw = function() {

				boardContext.shadowColor = 'rgba(50, 50, 50, 0.25)';
				boardContext.shadowOffsetX = 0;
				boardContext.shadowOffsetY = 3;
				boardContext.shadowBlur = 6;

				boardContext.beginPath();
				boardContext.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);
				boardContext.fillStyle = this.color;
				boardContext.fill();

		}

		// Move disc with physic's applied
		this.move = function() {

				// Apply friction
				this.velocityX *= this.frictionX;
				this.velocityY *= this.frictionY;

				// Update position
				this.x += this.velocityX;
				this.y += this.velocityY;
		}

		// Play against a computer
		this.computerPlayer = function() {
			
				// If pucks about to move into right hand side of screen
				// And controller isnt pushed up against the center line
				if (puck.x > (boardCenterX - 30) && controllerTwo.x > (boardCenterX + controllerTwo.radius * 2)) {

						// Work out if puck is infront or behind controller
						// Try to hit the puck on right hand side and at the center.
						
						// If puck is infront on controller
						if ((puck.x + puck.radius) < controllerTwo.x) {
							  controllerTwo.velocityX -= controllerTwo.acceleration;
						} else {
								controllerTwo.velocityX += controllerTwo.acceleration;
						}
					
						// Do same on y axis
						if (puck.y < controllerTwo.y) {
								controllerTwo.velocityY -= controllerTwo.acceleration;
						} else {
								// Is behind
								controllerTwo.velocityY += controllerTwo.acceleration;
						}

				} else {

					  // Move back to its starting position so its not stuck at center line. 
					  // Give it a range to top in
						if (controllerTwo.x > (controllerTwo.startingPosX - 50) && controllerTwo.x < (controllerTwo.startingPosX + 50)) {
								controllerTwo.velocityX = 0;
						} else if (controllerTwo.x < (controllerTwo.startingPosX - 80)) {
								controllerTwo.velocityX += controllerTwo.acceleration;
						} else {
								controllerTwo.velocityX -= controllerTwo.acceleration;
						}

				}

		}

};

// Run game functions
function updateGame() {

		// Clear board
		boardContext.clearRect(0, 0, boardWidth, boardHeight);
		// Draw & contain puck
		puck.draw();
		puck.move();
		puck.discCollision();
		puck.keepPuckInBoard();
		// Controllers
		controller.draw();
		controller.move();
		controller.keepControllerInBoard();
		controllerTwo.draw();
		controllerTwo.computerPlayer();
		controllerTwo.move();
		controllerTwo.keepControllerInBoard();

		// Loop
		requestAnimationFrame(updateGame);

}

// Keyboard events
function moveController(key) {

		// Up
		if (key === 38 && controller.velocityY < controller.maxSpeed) {
				controller.velocityY -= controller.acceleration;
		}

		// Down
		if (key === 40 && controller.velocityY < controller.maxSpeed) {
				controller.velocityY += controller.acceleration;
		}

		// Right
		if (key === 39 && controller.velocityX < controller.maxSpeed) {
				controller.velocityX += controller.acceleration;
		}

		// Left, decrease acceleration
		if (key === 37 && controller.acceleration < controller.maxSpeed) {
				controller.velocityX -= controller.acceleration;
		}
	
}

function rotate(x, y, sin, cos, reverse) {
		return {
				x: (reverse) ? (x * cos + y * sin) : (x * cos - y * sin),
				y: (reverse) ? (y * cos - x * sin) : (y * cos + x * sin)
		};
}

// Events
document.addEventListener("keydown", function(e) {
		moveController(e.keyCode);
});

// Add puck
var puck = new Disc();

// Add controller & adjust settings
var controller = new Disc();
controller.color = '#2132CC';
controller.radius += 10;
controller.acceleration = 5;
controller.startingPosX = 125;
controller.mass = 50;
controller.x = controller.startingPosX;

// Add controller two
var controllerTwo = new Disc();
controllerTwo.color = '#2132CC';
controllerTwo.radius += 10;
controllerTwo.mass = 50;
controllerTwo.startingPosX = (boardWidth - 155);
controllerTwo.acceleration = 0.2;
controllerTwo.x = controllerTwo.startingPosX;

// Store controllers
controllers.push(controller, controllerTwo);

// Start game
updateGame();
	</script>
</body>
</head>
</html>